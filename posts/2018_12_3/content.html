<script local src="js/vector.js"></script>
<script local src="js/gridPoint.js"></script>
<script local src="js/grid.js"></script>
<script local src="js/gui.js"></script>
<script local src="js/simulation.js"></script>
<script local src="js/agents/types.js"></script>
<script local src="js/agents/agent.js"></script>
<script local src="js/agents/plant.js"></script>
<script local src="js/agents/rabbit.js"></script>
<script local src="js/agents/fox.js"></script>
<script local src="js/agents/colors.js"></script>
<script local src="js/agents/names.js"></script>
<script local src="js/agents/objects.js"></script>
<script local src="js/gridRenderer.js"></script>
<script local src="js/tileRenderer.js"></script>
<script local src="js/graphRenderer.js"></script>
<script local src="js/action.js"></script>
<script local src="js/context.js"></script>
<script local src="js/instance.js"></script>
<h2>Closed ecosystems</h2>
<p>The type of ecosystem I want to simulate is a <em>closed ecosystem</em>. This means nothing enters or leaves the system from the outside world. In this way, ecosystems can never lose all their contents and die as a result, and organisms inside it cannot cheat by giving themselves something that didn't exist in the ecosystem before.</p>
<figure title="A closed ecosystem">
	<img local src="img/ecosystem.jpg">
	<figcaption>Figure 1: The closed ecosystem in my windowsill.</figcaption>
</figure>
<p>As an experiment, I have created such a system myself a while ago. Figure 1 shows the system in its current state. It is a simple mason jar filled with some gravel, water and plants from a nearby lake. At first, the water looked dirty and green and the plants didn't look too healthy. After a while though, the water became clear and plants started to root in the gravel. It was then I could also see the animals inhabiting the system; a small number of snails were crawling along the glass and hundreds of tiny crustaceans were swimming around and feeding on the plants.</p>
<p>Because the jar has an airtight seal, no matter ever enters or leaves the system after it has been closed. Sunlight is the only exception. The plants and algae use the sunlight as an energy source and produce biomass and oxygen as a result. The animals consume the plants and the oxygen, and their droppings and bodies will eventually be a food source for the plants again. As long as energy is provided to the system through sunlight, this cycle could theoretically last forever, and my small ecosystem has indeed been stable for a long time now.</p>
<h2>Making a model</h2>
<p>After observing both the theory of a closed system and the practice of the jar in my window, I have defined a list of requirements for the simulation in which I want to capture the system:</p>
<ul>
	<li>The system must have a <em>constant mass</em>, no mass goes in or out.</li>
	<li>The system exists in a limited space.</li>
	<li>Mass is distributed over two categories:<ol>
			<li>Living mass, consisting of plants and animals.</li>
			<li>Dead mass, consisting of organism remains and droppings.</li>
		</ol>
	</li>
</ul>
<p>This list is a bit too brief to base a digital simulation on, so I've also made some choices regarding the implementation:</p>
<ul>
	<li>Mass will be a whole number, and every organism has mass. I use whole numbers to avoid violating the first requirement through rounding errors.</li>
	<li>The simulation takes place on a hexagonal grid. I favor this shape over squares for the following reasons:<ol>
			<li>All neighbors are at equal distance from a hexagons center.</li>
			<li>Hexagons have six neighbors instead of eight. This saves some performance.</li>
		</ol>
	</li>
	<li>Every tile has a certain amount of dead mass (I call it <em>fertilizer</em>), and at most one <em>agent</em> (a plant or animal).</li>
	<li>Agents can consume both fertilizer and other agents. However, agents can only eat other agents if they are at least twice as heavy as their prey.</li>
	<li>Agents can perform a fixed number of actions, and every action reduces an agent's mass by an amount that is proportional to its mass. The reduced mass is then dropped as fertilizer.</li>
</ul>
<p>The last two points are most important when it comes to implementing the agents. Because the number of possible actions is fixed, we leave no room to cheat. Every organism can perform the same actions, nothing more or less. Every action then has an energy cost which is determined globally and is proportional to its mass. Moving to a neighboring tile for example could have a cost of 5%. This means that an agent with a weight of 100 grams would lose 5 grams because of this action, and drop 5 grams as fertilizer on the tiles around it. A bigger organism of 1000 grams would lose 50 grams however, so bigger organisms will need to eat more as well. On the other hand, an organism needs to be significantly heavier than its prey to be able to eat them.</p>
<figure title="Agent actions">
	<table style="width: 350px">
		<tr>
			<td>Name</td>
			<td>Cost</td>
			<td>Description</td>
		</tr>
		<tr>
			<td>Idle</td>
			<td>1%</td>
			<td>Do nothing. If any of the subsequent actions fails, this action will be performed.</td>
		</tr>
		<tr>
			<td>Move</td>
			<td>15%</td>
			<td>Move to a neighboring tile.</td>
		</tr>
		<tr>
			<td>Eat fertilizer</td>
			<td>0%</td>
			<td>The agent eats a certain amount of fertilizer from the ground.</td>
		</tr>
		<tr>
			<td>Eat agent</td>
			<td>0%</td>
			<td>The agent eats a neighboring agent. The neighbors' mass is added to the agent.</td>
		</tr>
		<tr>
			<td>Copy</td>
			<td>10%</td>
			<td>Copy the agent to a neighboring cell. The agent keeps half of its mass, and the new agent will get the other half.</td>
		</tr>
		<tr>
			<td>Die</td>
			<td>100%</td>
			<td>The agent dies.</td>
		</tr>
	</table>
	<figcaption>Figure 2: All possible actions agents may perform.</figcaption>
</figure>
<h2>Actions</h2>
<p>Figure 2 contains a table containing all possible actions agents can perform. The mass cost is also determined. The agent should be able to show some intelligence in its actions. To make informed decisions, the agent should be able to sense its surroundings. For this, a <em>context</em> is provided. The context contains the following information:</p>
<ul>
	<li>All neighboring agents.</li>
	<li>The amount of fertilizer in the tile the agent is on.</li>
	<li>The accessibility of the tiles around the agents.</li>
</ul>
<p>A single function is responsible for an agent's behavior. This function takes a context as an argument, and returns an action. If this action turns out to be impossible (for example if an agent tries to move to a tile where another agent already is), the idle action will be performed instead. Because of this, every agent will perform some action whenever the simulation is updated.</p>
<p>Finally, every agent must have a minimum mass. If an agent falls below that mass, the agent will die. You might think entering the lowest possible mass would be cheating here. It turns out this is not the case, but more on this later.</p>
<h2>Plants and rabbits</h2>
<p>I have implemented the simulation described above. To demonstrate it, I have also implemented two rather simple agents.</p>
<p>The <em>plant</em> consumes fertilizer from the ground at a slow rate, or idles when not enough fertilizer is available. When a certain mass threshold is reached, the plant tries to copy itself to a free neighboring tile.</p>
<p>The <em>rabbit</em> looks in a certain direction and eats a plant if it sees one. When a plant is eaten, the rabbit continues to move into that direction hoping to find more plants. When no plant is found, the rabbit moves around randomly. If the rabbit's mass gets very low, the rabbit tends to idle to conserve energy.</p>
<div id="sim-plants-rabbits" class="simulation">
	<div class="wrapper">
		<div class="grid">
			<div class="legend-area"></div>
		</div>
		<div class="graph">
			<div class="legend-area"></div>
		</div>
	</div>
	<div class="controls">
		<label>
			<input class="frame" type="text" readonly>
		</label>
		<button class="stop">◼</button>
		<button class="play">►</button>
		<button class="step">Step</button>
		<button class="reset">Reset</button>
	</div>
</div>
<div id="sim-plants-rabbits-controls"></div>
<script local src="js/simPlantsRabbits.js"></script>
<p>While the simulation runs, a graph is generated below it. This graph shows how the biomass of the system is built up. Most of it is gray, this is the dead biomass or fertilizer. A part of it consists of the organisms in the legend, plants and rabbits in this case. Usually, the course of the simulation follows a predictable pattern:</p>
<ul>
	<li>The plants grow quickly.</li>
	<li>Because there is more food, the population of rabbits grows too.</li>
	<li>The number of plants decreases because of the eating rabbits.</li>
	<li>The number of rabbits decreases because there are less plants.</li>
</ul>
<p>This process repeats indefinitely, or until an unfortunate twist of fate causes the rabbits to go extinct. After initialization, the situation is very random and unstable. At first, big shifts in populations occur often. After a few waves though, the simulation seems to become more stable. This is similar to the early behavior of my ecosystem in a jar: the water quality and animal populations showed a few peaks and valleys before finally stabilising.</p>