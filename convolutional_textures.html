<!DOCTYPE html><html><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-109031298-1"></script><script src="js/google.js"></script><title>Job Talle | Convolutional textures</title><meta charset="UTF-8"><meta name="description" content=""/><meta name="keywords" content="game development, AI, algorithms, programming, job talle"/><meta name="author" content="Job Talle"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:locale" content="en_US"/><meta property="og:title" content="Convolutional textures"/><meta property="og:url" content="https://jobtalle.com/convolutional_textures.html"/><meta property="og:description" content=""/><meta property="og:image" content="https://jobtalle.com/posts/2019_1_3/img/preview.jpg"/><meta property="twitter:image" content="https://jobtalle.com/posts/2019_1_3/img/preview.jpg"/><meta property="twitter:description" content=""/><meta property="twitter:site" content="jobtalle.com"/><meta property="twitter:card" content="summary"/><meta property="twitter:title" content="Convolutional textures"/><link href="https://fonts.googleapis.com/css?family=Raleway" rel="stylesheet"/><link rel="shortcut icon" type="image/gif" href="img/favicon.gif"/><link rel="stylesheet" type="text/css" href="css/style.css"/><link rel="stylesheet" type="text/css" href="posts/2019_1_3/css/style.css"></head><body><div id="container"><div id="menu-wrapper"><div id="menu-buttons"><a href="index.html"><div class="menu-button">Blog</div></a><a href="about.html"><div class="menu-button">About</div></a><a href="contact.html"><div class="menu-button">Contact</div></a></div></div><div id="wrapper" class="container"><div id="header"><h1>Job Talle</h1><h2>On game development, AI & Algorithms</h2></div><div id="content"><h1>Convolutional textures</h1><span class="date">3 Jan 2019</span><h2>Self-updating textures</h2><p>When simulations or rendering tasks can be parallellized, it is usually a good idea to perform them on the GPU. In this article, I will explain a technique using this fact to achieve impressive visual tricks at a low performance cost. All effects I'm about to demonstrate are achieved through textures that "render to themselves" when they are updated; the texture is updated whenever a new frame is rendered, and the next state of the texture depends completely on the previous state. Certain shapes can be painted onto these textures at any time to trigger certain changes, and the texture can be used directly or indirectly to render interesting animations. I call them <em>Convolutional textures</em>.</p><figure title="Double buffering">    <img src="posts/2019_1_3/img/frontback.jpg">    <figcaption>Figure 1: Double buffering of a convolutional texture.</figcaption></figure><p>Before continuing, there is already a problem that needs to be solved: a texture cannot be read from and written to at the same time, graphics API's like OpenGL and DirectX don't allow this. Because the next state of a texture depends on the previous state, a fix is needed. I need to read from a different source than the one I'm writing to.</p><p><em>Double buffering</em> provides a solution. Figure 1 shows how this works: there are actually to textures instead of one, but one of them is being written to while the other one is being read. The texture being written to is known as the <em>back buffer</em>, and the one being rendered is the <em>front buffer</em>. Because a convolutional texture "writes to itself", the back buffer writes to the front buffer on every frame, and then the front buffer is shown. When the next frame arrives, the roles are swapped and the previous front buffer is used as a source for the next front buffer.</p><p>A convolutional texture achieves interesting effects and animations by using a specific <em>fragment shader</em> (or <em>pixel shader</em>) to render the previous state to the next one. The shader determines how the state changes. The source code of all examples in this article (and more) can be found <a href="https://github.com/jobtalle/ConvolutionalTextures" target="_blank">in this repository on GitHub</a>.</p><h2>Simple applications</h2><p>To demonstrate this technique, I've chosen a well known simulation where the state depends completely on the previous state when updating: <em>Conway's game of life</em>. This simulation takes place on a square grid, and every cell is either alive or dead. The rules for the next state of a cell are simple:</p><ul>    <li>If a living cell has less than two neighbors, it becomes a dead cell.</li>    <li>If a living cell has two or three living neighbors, it remains alive.</li>    <li>If a living cell has more than three living neighbors, it becomes a dead cell.</li>    <li>If a dead cell has three living neighbors, it becomes a living cell.</li></ul><p>To implement this game as a convolutional texture, I interpret the texture as the game's grid, and the shader renders using the rules above. A transparent pixel is a dead cell, and a white opaque pixel is a living cell. This interactive implementation is shown below. To get access to the GPU, I'm using <a href="https://github.com/jobtalle/myr.js" target="_blank"><em>myr.js</em></a>, which requires <em>WebGL 2</em>. Most modern browsers can run this, but if it doesn't work, your browser most likely doesn't support it yet. Use the mouse (or a touchscreen) to paint living cells on the texture.</p><div class="simulation" id="game-of-life"></div><p>Another simple convolutional texture is the <em>falling sand game</em>, where the user can throw colored sand into the scene that will fall and form heaps. Although the implementation is a bit more complex, the rules are simpler:</p><ul>    <li>If there is no sand below a grain of sand, fall one pixel down.</li>    <li>If there is sand below a grain of sand, but it can slide down 45 degrees in either direction, it will do so.</li></ul><p>The controls for this example are the same as they were in the game of life above. Because the sand can only fall with a speed of one pixel per frame using these rules, the texture updates three times frame to speed it up a little.</p><div class="simulation" id="falling-sand"></div><p></p><h2>A different interpretation</h2><h2>Other uses & caveats</h2><h2>Conclusion</h2><script src="lib/myr/myr.js"></script><script src="posts/2019_1_3/js/convTex.js"></script><script src="posts/2019_1_3/js/mouse.js"></script><script src="posts/2019_1_3/js/life.js"></script><script src="posts/2019_1_3/js/sand.js"></script><script src="posts/2019_1_3/js/setup.js"></script><div id="references"><a href="simulated_ecosystems.html" title="Previously: Simulated ecosystems"><div class="post-reference post-reference-left">Simulated ecosystems</div></a></div></div><div id="footer">&copy Job Talle </div><div id="icons"><a href="contact.html"><div class="icon" id="icon-mail" title="Mail"></div></a><a href="https://www.github.com/jobtalle" target="_blank"><div class="icon" id="icon-github" title="Github"></div></a><a href="https://twitter.com/jobtalle" target="_blank"><div class="icon" id="icon-twitter" title="Twitter"></div></a><a href="https://www.linkedin.com/in/job-talle-b2b582aa" target="_blank"><div class="icon" id="icon-linkedin" title="LinkedIn"></div></a></div></div></div><script src="js/setyear.js"></script></body></html>